### . نقش ورکر (The Executor)

ورکر کدهای ورک‌فلو را اجرا می‌کند. پس از اجرا، ورکر یک اتصال دائمی به کلاستر برقرار کرده و مدام یک **Task Queue** (صف وظایف) را چک می‌کند (Polling) تا ببیند آیا کار جدیدی برای انجام دادن هست یا خیر.

> **نکته:** اگر ورکری در حال اجرا نباشد، ورک‌فلوهای شما هیچ پیشرفتی نخواهند داشت.

### ۲. سه رکن اصلی برای راه‌اندازی ورکر

برای اینکه یک ورکر را در Go استارت بزنید، به سه چیز نیاز دارید:

1. **Temporal Client:** پلی برای صحبت با کلاستر.
    
2. **Task Queue Name:** نام صفی که ورکر باید از آن دستور بگیرد (مثلاً `greeting-tasks`).
    
3. **Registration:** معرفی کردن تابعِ ورک‌فلو به ورکر (تا ورکر بداند چه کدهایی را بلد است اجرا کند).
    

---

### ۳. کالبدشکافی کد Go

در کدی که فرستادی، این اتفاقات می‌افتد:

- **`client.Dial`**: اتصال به کلاستر (اگر روی لوکال باشد، تنظیمات پیش‌فرض کافیست).
    
- **`worker.New`**: ساخت یک ورکر جدید که گوش‌به‌زنگِ یک صف خاص است.
    
- **`w.RegisterWorkflow`**: ثبت کردن تابع ورک‌فلو در حافظه‌ی ورکر.
    
- **`w.Run`**: اجرای ورکر. این تابع **Blocking** است؛ یعنی برنامه در همین خط می‌ماند و مدام صف را چک می‌کند تا زمانی که خودتان آن را متوقف کنید.
    

### ۴. طول عمر ورکر (Worker vs Workflow)

این یکی از جذاب‌ترین ویژگی‌های تمپورال است: **عمر ورکر و ورک‌فلو به هم وابسته نیست!**

- یک ورکر ممکن است ماه‌ها روشن باشد و میلیون‌ها ورک‌فلو را انجام دهد.
    
- اگر ورکر کرش کند یا سرور ری‌بوت شود، ورک‌فلو خراب نمی‌شود! به محض اینکه ورکر دوباره بالا بیاید (یا یک ورکر دیگر در همان صف روشن شود)، کار را دقیقاً از همان‌جایی که مانده بود ادامه می‌دهد.
    

### ۵. انتخاب نام برای Task Queue

- نام‌ها **Case-sensitive** (حساس به حروف کوچک و بزرگ) هستند.
    
- نامی انتخاب کنید که کوتاه و توصیفی باشد (مثل `shipping-tasks` به جای `stq` یا یک نام خیلی طولانی).