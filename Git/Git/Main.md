 **ماهیت شاخه Main (مخزن تجمعی)**
​حق با توست؛ شاخه main لزوماً یک داستان خطی درباره «یک موضوع» نیست. شاخه main در واقع خط زمانی پروژه است. ممکن است کامیت C مربوط به اصلاح رنگ دکمه باشد و کامیت D مربوط به تنظیمات دیتابیس. این‌ها رابطه معنایی مستقیم ندارند، اما از نظر زمانی بعد از هم اتفاق افتاده‌اند.

![[tempFileForShare_20260129-100510.jpg]]

**اتفاقی که در Merge می‌افتد**

- ​همان‌طور که در بخش دوم تصویر (After git merge) می‌بینی:
- ​گیت یک کامیت جدید به نام 'G می‌سازد.
- ​این کامیت مثل یک «گره» عمل می‌کند که دو سر طناب را به هم وصل کرده است.
- ​نکته طلایی: در این حالت، گیت تاریخچه را دستکاری نمی‌کند. فقط می‌گوید: «در این لحظه، کدهای شاخه Feature (یعنی E, F, G) با کدهای Main ادغام شدند». تاریخچه شاخه‌شاخه باقی می‌ماند.

___

**اتفاقی که در [[Rebase]] می‌افتد**

- ​در بخش سوم (After git rebase)، اتفاق عجیبی می‌افتد:
- ​گیت کامیت‌های تو را (E, F, G) برمی‌دارد و آن‌ها را بازنویسی می‌کند (تبدیل می‌شوند به 'E', F', G).
- ​حالا این کامیت‌های جدید را می‌برد و دقیقاً می‌چسباند جلوی D.
- ​معنای این کار: با Rebase، تو داری به تاریخچه دروغ می‌گویی! تو می‌گویی: «من اصلاً کارم را از کامیت B شروع نکردم؛ من کارم را زمانی شروع کردم که کامیت D هم آماده بود.»

___

**خلاصه کلام:**
شاخه main مثل یک اتوبان اصلی است. [[Merge]] مثل این است که یک رمپ ورود به اتوبان بسازی (معلوم است از کجا آمده‌ای). [[Rebase]] مثل این است که ماشینت را با جرثقیل بلند کنی و وسط اتوبان بگذاری (انگار از اول توی اتوبان بودی).
